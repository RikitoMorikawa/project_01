name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: "デプロイするバージョン"
        required: true
        default: "latest"
      rollback:
        description: "ロールバック実行（true/false）"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "テストをスキップ（緊急時のみ）"
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: ap-northeast-1
  ENVIRONMENT: prod
  PROJECT_NAME: csr-lambda-api

jobs:
  pre-deployment-check:
    name: デプロイ前チェック
    runs-on: ubuntu-latest

    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      rollback-mode: ${{ steps.check.outputs.rollback-mode }}

    steps:
      - name: コードをチェックアウト
        uses: actions/checkout@v4

      - name: デプロイ前チェック
        id: check
        run: |
          echo "=== 本番デプロイ前チェック ==="
          echo "バージョン: ${{ github.event.inputs.version }}"
          echo "ロールバック: ${{ github.event.inputs.rollback }}"
          echo "テストスキップ: ${{ github.event.inputs.skip_tests }}"

          if [[ "${{ github.event.inputs.rollback }}" == "true" ]]; then
            echo "ロールバックモードで実行します"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "rollback-mode=true" >> $GITHUB_OUTPUT
          else
            echo "通常デプロイモードで実行します"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "rollback-mode=false" >> $GITHUB_OUTPUT
          fi

  test:
    name: 本番環境用厳格テスト
    runs-on: ubuntu-latest
    needs: pre-deployment-check
    if: needs.pre-deployment-check.outputs.should-deploy == 'true' && needs.pre-deployment-check.outputs.rollback-mode == 'false' && github.event.inputs.skip_tests != 'true'

    steps:
      - name: コードをチェックアウト
        uses: actions/checkout@v4

      - name: Python 環境をセットアップ
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Node.js 環境をセットアップ
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: バックエンド依存関係をインストール
        run: |
          cd backend
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: フロントエンド依存関係をインストール
        run: |
          cd frontend
          npm ci --production=false

      - name: バックエンド厳格テストを実行
        run: |
          cd backend
          # テストファイルが存在する場合のみ実行
          if [ -d "tests" ] && [ "$(find tests -name '*.py' | wc -l)" -gt 0 ]; then
            # pytest-cov が利用可能かチェック
            if python -c "import pytest_cov" 2>/dev/null; then
              python -m pytest tests/ -v --tb=short --cov=app --cov-report=xml --cov-fail-under=80
            else
              echo "pytest-cov が見つかりません。カバレッジなしでテストを実行します。"
              python -m pytest tests/ -v --tb=short
            fi
          else
            echo "テストファイルが見つかりません。テストをスキップします。"
          fi

      - name: フロントエンド厳格テストを実行
        run: |
          cd frontend
          # リント実行（厳格）
          if npm run lint --silent 2>/dev/null; then
            npm run lint
          else
            echo "リントスクリプトが見つかりません。スキップします。"
          fi

          # 型チェック実行（厳格）
          if npm run type-check --silent 2>/dev/null; then
            npm run type-check
          else
            echo "型チェックスクリプトが見つかりません。スキップします。"
          fi

          # テスト実行（カバレッジ閾値付き）
          if npm test --silent 2>/dev/null; then
            npm test -- --coverage --watchAll=false --coverageThreshold='{"global":{"branches":70,"functions":70,"lines":70,"statements":70}}'
          else
            echo "テストスクリプトが見つかりません。スキップします。"
          fi

      - name: 本番環境用セキュリティスキャンを実行
        run: |
          # バックエンドセキュリティスキャン（厳格）
          cd backend
          pip install safety bandit

          echo "=== Safety チェック実行（厳格） ==="
          safety check --json

          echo "=== Bandit セキュリティスキャン実行（厳格） ==="
          bandit -r app/ -f json

          cd ..

          # フロントエンドセキュリティスキャン（厳格）
          echo "=== npm audit 実行（厳格） ==="
          cd frontend
          npm audit --audit-level=moderate
          cd ..

      - name: パフォーマンステストを実行
        run: |
          cd frontend
          # 環境変数ファイルの作成（テスト用）
          cat > .env.production << EOF
          NEXT_PUBLIC_API_URL=https://test-api.example.com
          NEXT_PUBLIC_ENVIRONMENT=prod
          NEXT_PUBLIC_AWS_REGION=ap-northeast-1
          EOF

          # ビルドテスト（パフォーマンス分析付き）
          npm run build

          # バンドルサイズ分析
          if npm run build -- --analyze --silent 2>/dev/null; then
            npm run build -- --analyze
          else
            echo "バンドル分析スクリプトが見つかりません。スキップします。"
          fi

      - name: 本番用バックエンドパッケージングテスト
        run: |
          # ビルドディレクトリの作成
          mkdir -p build/backend

          # バックエンドファイルのコピー
          cp -r backend/app build/backend/
          cp backend/lambda_handler.py build/backend/
          cp backend/requirements.txt build/backend/

          # 依存関係のインストール（本番最適化）
          cd build/backend
          pip install -r requirements.txt -t . --no-deps --compile
          pip install -r requirements.txt -t . --upgrade --compile

          # 不要なファイルを削除
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.so" -exec strip {} + 2>/dev/null || true
          find . -name "*.py" -exec python3 -m py_compile {} + 2>/dev/null || true

          # デプロイメントパッケージの作成
          zip -9 -r ../lambda-deployment-package.zip . -x "*.git*" "*.DS_Store*" "tests/*" "*.pytest_cache*" "*.coverage*" "*.md" "*.txt" "*.rst"

          # パッケージサイズの確認（厳格）
          PACKAGE_SIZE=$(stat -f%z ../lambda-deployment-package.zip 2>/dev/null || stat -c%s ../lambda-deployment-package.zip)
          echo "Lambda パッケージサイズ: $PACKAGE_SIZE bytes"

          # 50MB制限の確認
          if [ $PACKAGE_SIZE -gt 52428800 ]; then
            echo "エラー: Lambdaパッケージが50MBを超えています"
            exit 1
          fi

  deploy:
    name: 本番環境デプロイ
    needs: [pre-deployment-check, test]
    runs-on: ubuntu-latest
    if: always() && needs.pre-deployment-check.outputs.should-deploy == 'true' && (needs.test.result == 'success' || needs.test.result == 'skipped' || needs.pre-deployment-check.outputs.rollback-mode == 'true')

    environment:
      name: production
      url: ${{ steps.deploy-info.outputs.frontend-url }}

    steps:
      - name: コードをチェックアウト
        uses: actions/checkout@v4

      - name: Python 環境をセットアップ
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Node.js 環境をセットアップ
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: AWS 認証情報を設定
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: AWS 認証情報を確認
        run: |
          echo "AWS認証情報を確認中..."
          aws sts get-caller-identity
          export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "STACK_PREFIX=${PROJECT_NAME}-${ENVIRONMENT}" >> $GITHUB_ENV

      - name: 必要なツールをインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y jq zip unzip bc

      - name: ロールバック実行
        if: needs.pre-deployment-check.outputs.rollback-mode == 'true'
        run: |
          echo "=== 本番環境ロールバック実行 ==="

          # Lambda関数の前のバージョンに戻す
          if aws lambda get-alias --function-name "${STACK_PREFIX}-api-function" --name "LIVE" --region "$AWS_REGION" >/dev/null 2>&1; then
            CURRENT_VERSION=$(aws lambda get-alias \
              --function-name "${STACK_PREFIX}-api-function" \
              --name "LIVE" \
              --region "$AWS_REGION" \
              --query 'FunctionVersion' \
              --output text)
            
            echo "現在のバージョン: $CURRENT_VERSION"
            
            # 前のバージョンを取得（簡単な例として-1）
            if [ "$CURRENT_VERSION" != "1" ]; then
              PREVIOUS_VERSION=$((CURRENT_VERSION - 1))
              
              echo "前のバージョンにロールバック中: $PREVIOUS_VERSION"
              aws lambda update-alias \
                --function-name "${STACK_PREFIX}-api-function" \
                --name "LIVE" \
                --function-version "$PREVIOUS_VERSION" \
                --region "$AWS_REGION"
              
              echo "✅ Lambda関数のロールバックが完了しました"
            else
              echo "ロールバック可能な前のバージョンがありません"
            fi
          fi

          echo "🔄 ロールバックが完了しました"
          exit 0

      - name: インフラストラクチャをデプロイ
        if: needs.pre-deployment-check.outputs.rollback-mode == 'false'
        run: |
          echo "=== 本番インフラストラクチャデプロイ開始 ==="
          cd infrastructure/prod
          chmod +x deploy.sh
          ./deploy.sh

      - name: バックエンドをビルド
        if: needs.pre-deployment-check.outputs.rollback-mode == 'false'
        run: |
          echo "=== 本番バックエンドビルド開始 ==="

          # ビルドディレクトリの作成
          mkdir -p build/backend

          # バックエンドファイルのコピー
          cp -r backend/app build/backend/
          cp backend/lambda_handler.py build/backend/
          cp backend/requirements.txt build/backend/

          # 依存関係のインストール（本番最適化）
          cd build/backend
          pip install --upgrade pip
          pip install -r requirements.txt -t . --no-deps --compile
          pip install -r requirements.txt -t . --upgrade --compile

          # 不要なファイルを削除
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.so" -exec strip {} + 2>/dev/null || true
          find . -name "*.py" -exec python3 -m py_compile {} + 2>/dev/null || true

          # デプロイメントパッケージの作成（本番最適化）
          zip -9 -r ../lambda-deployment-package.zip . -x "*.git*" "*.DS_Store*" "tests/*" "*.pytest_cache*" "*.coverage*" "*.md" "*.txt" "*.rst"
          cd ../..

      - name: バックエンドをデプロイ（ブルーグリーンデプロイ）
        if: needs.pre-deployment-check.outputs.rollback-mode == 'false'
        run: |
          echo "=== 本番バックエンドデプロイ開始（ブルーグリーンデプロイ） ==="

          # S3バケットの設定
          LAMBDA_BUCKET="${PROJECT_NAME}-${ENVIRONMENT}-lambda-deployments-${AWS_ACCOUNT_ID}"
          LAMBDA_KEY="lambda-deployment-package-$(date +%Y%m%d-%H%M%S).zip"

          # S3バケットが存在しない場合は作成
          if ! aws s3 ls "s3://$LAMBDA_BUCKET" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "Lambda デプロイメント用 S3 バケットを作成中: $LAMBDA_BUCKET"
            aws s3 mb "s3://$LAMBDA_BUCKET" --region "$AWS_REGION"
            aws s3api put-bucket-versioning --bucket "$LAMBDA_BUCKET" --versioning-configuration Status=Enabled --region "$AWS_REGION"
          fi

          # デプロイメントパッケージをS3にアップロード
          echo "Lambdaパッケージを S3 にアップロード中..."
          aws s3 cp "build/lambda-deployment-package.zip" "s3://$LAMBDA_BUCKET/$LAMBDA_KEY" --region "$AWS_REGION"

          # Lambda関数の更新（ブルーグリーンデプロイ）
          if aws lambda get-function --function-name "${STACK_PREFIX}-api-function" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "Lambda関数を更新中..."
            
            # 新しいバージョンを作成
            NEW_VERSION=$(aws lambda update-function-code \
              --function-name "${STACK_PREFIX}-api-function" \
              --s3-bucket "$LAMBDA_BUCKET" \
              --s3-key "$LAMBDA_KEY" \
              --region "$AWS_REGION" \
              --query 'Version' \
              --output text)
            
            # 関数の更新完了を待機
            aws lambda wait function-updated \
              --function-name "${STACK_PREFIX}-api-function" \
              --region "$AWS_REGION"
            
            echo "新しいLambdaバージョン: $NEW_VERSION"
            
            # エイリアスの更新（段階的デプロイ）
            if aws lambda get-alias --function-name "${STACK_PREFIX}-api-function" --name "LIVE" --region "$AWS_REGION" >/dev/null 2>&1; then
              # 段階的デプロイ（10%から開始）
              echo "段階的デプロイを開始します（10%トラフィック）"
              aws lambda update-alias \
                --function-name "${STACK_PREFIX}-api-function" \
                --name "LIVE" \
                --function-version "$NEW_VERSION" \
                --routing-config "AdditionalVersionWeights={\"$NEW_VERSION\":0.1}" \
                --region "$AWS_REGION"
              
              echo "10%トラフィックで5分間監視します..."
              sleep 300  # 5分待機
              
              # ヘルスチェック
              API_URL=$(aws cloudformation describe-stacks \
                --stack-name "${STACK_PREFIX}-api" \
                --region "$AWS_REGION" \
                --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
                --output text 2>/dev/null || echo "")
              
              if [[ -n "$API_URL" ]]; then
                echo "新バージョンのヘルスチェックを実行中..."
                for i in {1..5}; do
                  if curl -f -s "${API_URL}/health" >/dev/null; then
                    echo "✅ 新バージョンヘルスチェック成功"
                    break
                  else
                    echo "⏳ 新バージョンヘルスチェック失敗 (試行 $i/5)"
                    if [ $i -eq 5 ]; then
                      echo "❌ 新バージョンヘルスチェック失敗 - ロールバックします"
                      # 前のバージョンに戻す
                      aws lambda update-alias \
                        --function-name "${STACK_PREFIX}-api-function" \
                        --name "LIVE" \
                        --function-version "\$LATEST" \
                        --region "$AWS_REGION"
                      exit 1
                    else
                      sleep 30
                    fi
                  fi
                done
              fi
              
              # 100%に切り替え
              echo "100%トラフィックに切り替え中..."
              aws lambda update-alias \
                --function-name "${STACK_PREFIX}-api-function" \
                --name "LIVE" \
                --function-version "$NEW_VERSION" \
                --region "$AWS_REGION"
              
              echo "✅ 本番デプロイが完了しました（100%トラフィック）"
            else
              # エイリアスを作成
              aws lambda create-alias \
                --function-name "${STACK_PREFIX}-api-function" \
                --name "LIVE" \
                --function-version "$NEW_VERSION" \
                --region "$AWS_REGION"
            fi
          else
            echo "Lambda関数が見つかりません。インフラストラクチャを先にデプロイしてください。"
          fi

      - name: フロントエンドをビルド
        if: needs.pre-deployment-check.outputs.rollback-mode == 'false'
        run: |
          echo "=== 本番フロントエンドビルド開始 ==="
          cd frontend

          # 依存関係のインストール
          npm ci --production=false

          # API Gateway URLを取得
          API_URL=""
          if aws cloudformation describe-stacks --stack-name "${STACK_PREFIX}-api" --region "$AWS_REGION" >/dev/null 2>&1; then
            API_URL=$(aws cloudformation describe-stacks \
              --stack-name "${STACK_PREFIX}-api" \
              --region "$AWS_REGION" \
              --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
              --output text 2>/dev/null || echo "")
          fi

          echo "API URL: $API_URL"

          # 環境変数ファイルの作成
          cat > .env.production << EOF
          NEXT_PUBLIC_API_URL=${API_URL}
          NEXT_PUBLIC_ENVIRONMENT=${ENVIRONMENT}
          NEXT_PUBLIC_AWS_REGION=${AWS_REGION}
          EOF

          # Next.js ビルド（本番最適化）
          NODE_ENV=production npm run build
          cd ..

      - name: フロントエンドをデプロイ
        if: needs.pre-deployment-check.outputs.rollback-mode == 'false'
        run: |
          echo "=== 本番フロントエンドデプロイ開始 ==="

          # S3バケット名を取得
          FRONTEND_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_PREFIX}-frontend" \
            --region "$AWS_REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendS3BucketName`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [[ -n "$FRONTEND_BUCKET" ]]; then
            echo "フロントエンドファイルを S3 にアップロード中: $FRONTEND_BUCKET"
            
            # バックアップの作成
            BACKUP_BUCKET="${FRONTEND_BUCKET}-backup"
            if aws s3 ls "s3://$BACKUP_BUCKET" --region "$AWS_REGION" >/dev/null 2>&1; then
              echo "現在のファイルをバックアップ中..."
              aws s3 sync "s3://$FRONTEND_BUCKET" "s3://$BACKUP_BUCKET" --region "$AWS_REGION" --delete
            fi
            
            # ビルドファイルをS3にアップロード
            cd frontend
            aws s3 sync out/ "s3://$FRONTEND_BUCKET" \
              --region "$AWS_REGION" \
              --delete \
              --cache-control "public, max-age=31536000, immutable" \
              --exclude "*.html" \
              --exclude "*.json" \
              --exclude "service-worker.js"
            
            # HTMLファイルとサービスワーカーは短いキャッシュ時間で設定
            aws s3 sync out/ "s3://$FRONTEND_BUCKET" \
              --region "$AWS_REGION" \
              --cache-control "public, max-age=300" \
              --include "*.html" \
              --include "*.json" \
              --include "service-worker.js"
            
            cd ..
            
            # CloudFrontの無効化
            CLOUDFRONT_DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
              --stack-name "${STACK_PREFIX}-frontend" \
              --region "$AWS_REGION" \
              --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
              --output text 2>/dev/null || echo "")
            
            if [[ -n "$CLOUDFRONT_DISTRIBUTION_ID" && "$CLOUDFRONT_DISTRIBUTION_ID" != "None" ]]; then
              echo "CloudFrontキャッシュを無効化中..."
              INVALIDATION_ID=$(aws cloudfront create-invalidation \
                --distribution-id "$CLOUDFRONT_DISTRIBUTION_ID" \
                --paths "/*" \
                --region "$AWS_REGION" \
                --query 'Invalidation.Id' \
                --output text)
              
              echo "CloudFront無効化ID: $INVALIDATION_ID"
              
              # 無効化完了を待機
              aws cloudfront wait invalidation-completed \
                --distribution-id "$CLOUDFRONT_DISTRIBUTION_ID" \
                --id "$INVALIDATION_ID" \
                --region "$AWS_REGION"
            fi
            
            echo "フロントエンドのデプロイが完了しました"
          else
            echo "フロントエンド S3 バケットが見つかりません。"
            exit 1
          fi

      - name: 本番環境統合テストを実行
        if: needs.pre-deployment-check.outputs.rollback-mode == 'false'
        run: |
          echo "=== 本番環境統合テスト実行 ==="

          # API Gateway URLを取得
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_PREFIX}-api" \
            --region "$AWS_REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [[ -n "$API_URL" && "$API_URL" != "取得できませんでした" ]]; then
            echo "本番API統合テストを実行中..."
            
            # ヘルスチェック（厳格）
            for i in {1..15}; do
              if curl -f -s "${API_URL}/health" >/dev/null; then
                echo "✅ 本番API ヘルスチェック成功"
                break
              else
                echo "⏳ 本番API ヘルスチェック失敗 (試行 $i/15)"
                if [ $i -eq 15 ]; then
                  echo "❌ 本番API ヘルスチェックが失敗しました"
                  exit 1
                else
                  sleep 20
                fi
              fi
            done
            
            # 基本的なAPIテスト
            echo "基本的なAPIテストを実行中..."
            
            # 認証なしエンドポイントのテスト
            if curl -f -s "${API_URL}/health" | jq -e '.status == "healthy"' >/dev/null 2>&1; then
              echo "✅ ヘルスチェックAPIテスト成功"
            elif curl -f -s "${API_URL}/health" | jq -e '.status' >/dev/null 2>&1; then
              echo "✅ ヘルスチェックAPIレスポンス確認"
            else
              echo "❌ ヘルスチェックAPIテスト失敗"
              exit 1
            fi
          else
            echo "❌ API URLが取得できません"
            exit 1
          fi

          # パフォーマンステスト
          echo "--- 本番環境パフォーマンステスト実行 ---"

          # CloudFront URLを取得
          CLOUDFRONT_URL=$(aws cloudfront describe-stacks \
            --stack-name "${STACK_PREFIX}-frontend" \
            --region "$AWS_REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionDomainName`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [[ -n "$CLOUDFRONT_URL" && "$CLOUDFRONT_URL" != "取得できませんでした" ]]; then
            echo "フロントエンドパフォーマンステストを実行中..."
            
            # 基本的なレスポンステスト
            RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "https://$CLOUDFRONT_URL")
            echo "フロントエンドレスポンス時間: ${RESPONSE_TIME}秒"
            
            # 2秒以内のレスポンスを期待
            if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
              echo "✅ フロントエンドパフォーマンステスト成功"
            else
              echo "⚠️ フロントエンドレスポンスが遅い可能性があります"
            fi
          fi

      - name: デプロイメント情報を取得
        id: deploy-info
        run: |
          echo "=== 本番環境デプロイメント情報 ==="

          # API Gateway URL
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_PREFIX}-api" \
            --region "$AWS_REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
            --output text 2>/dev/null || echo "取得できませんでした")
          echo "API Gateway URL: $API_URL"
          echo "api-url=$API_URL" >> $GITHUB_OUTPUT

          # CloudFront URL
          CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_PREFIX}-frontend" \
            --region "$AWS_REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionDomainName`].OutputValue' \
            --output text 2>/dev/null || echo "取得できませんでした")
          echo "Frontend URL (CloudFront): https://$CLOUDFRONT_URL"
          echo "frontend-url=https://$CLOUDFRONT_URL" >> $GITHUB_OUTPUT

          # データベースエンドポイント
          DB_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_PREFIX}-database" \
            --region "$AWS_REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseClusterEndpoint`].OutputValue' \
            --output text 2>/dev/null || echo "取得できませんでした")
          echo "Database Endpoint: $DB_ENDPOINT"
          echo "database-endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT

          # Lambda関数バージョン
          LAMBDA_VERSION=$(aws lambda get-alias \
            --function-name "${STACK_PREFIX}-api-function" \
            --name "LIVE" \
            --region "$AWS_REGION" \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "取得できませんでした")
          echo "Lambda Function Version: $LAMBDA_VERSION"
          echo "lambda-version=$LAMBDA_VERSION" >> $GITHUB_OUTPUT

      - name: デプロイメント完了通知
        run: |
          if [[ "${{ needs.pre-deployment-check.outputs.rollback-mode }}" == "true" ]]; then
            echo "🔄 本番環境ロールバックが完了しました！"
          else
            echo "🎉 本番環境へのデプロイが完了しました！"
            echo ""
            echo "📊 デプロイメント情報:"
            echo "- 環境: $ENVIRONMENT"
            echo "- バージョン: ${{ github.event.inputs.version }}"
            echo "- API URL: ${{ steps.deploy-info.outputs.api-url }}"
            echo "- フロントエンド URL: ${{ steps.deploy-info.outputs.frontend-url }}"
            echo "- データベース: ${{ steps.deploy-info.outputs.database-endpoint }}"
            echo "- Lambda バージョン: ${{ steps.deploy-info.outputs.lambda-version }}"
            echo ""
            echo "🔗 本番アプリケーション: ${{ steps.deploy-info.outputs.frontend-url }}"
            echo ""
            echo "✅ 統合テスト完了"
            echo "🔒 セキュリティスキャン完了"
            echo "⚡ パフォーマンステスト完了"
            echo "🔄 ブルーグリーンデプロイ完了"
          fi
