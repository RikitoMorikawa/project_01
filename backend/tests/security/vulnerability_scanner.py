"""
脆弱性スキャナー

アプリケーションの一般的な脆弱性をチェックするスクリプト
"""

import requests
import json
import time
import logging
from typing import List, Dict, Any
from urllib.parse import urljoin
import concurrent.futures
from dataclasses import dataclass
import argparse

# ログ設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityResult:
    """脆弱性スキャン結果"""
    test_name: str
    severity: str  # LOW, MEDIUM, HIGH, CRITICAL
    status: str    # PASS, FAIL, WARNING
    description: str
    details: Dict[str, Any]
    recommendation: str


class SecurityScanner:
    """セキュリティスキャナー"""
    
    def __init__(self, base_url: str, timeout: int = 10):
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        self.results: List[VulnerabilityResult] = []
        
        # デフォルトヘッダー
        self.session.headers.update({
            'User-Agent': 'SecurityScanner/1.0'
        })
    
    def scan_all(self) -> List[VulnerabilityResult]:
        """全ての脆弱性スキャンを実行"""
        
        logger.info(f"セキュリティスキャンを開始: {self.base_url}")
        
        # スキャンテストを並列実行
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [
                executor.submit(self.test_security_headers),
                executor.submit(self.test_ssl_configuration),
                executor.submit(self.test_information_disclosure),
                executor.submit(self.test_authentication_bypass),
                executor.submit(self.test_sql_injection),
                executor.submit(self.test_xss_protection),
                executor.submit(self.test_csrf_protection),
                executor.submit(self.test_rate_limiting),
                executor.submit(self.test_directory_traversal),
                executor.submit(self.test_http_methods),
                executor.submit(self.test_cors_configuration),
                executor.submit(self.test_error_handling)
            ]
            
            # 結果を収集
            for future in concurrent.futures.as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"スキャンテストでエラーが発生: {str(e)}")
        
        logger.info(f"セキュリティスキャンが完了: {len(self.results)} 件の結果")
        return self.results
    
    def test_security_headers(self):
        """セキュリティヘッダーのテスト"""
        
        try:
            response = self.session.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
            headers = response.headers
            
            # 必須セキュリティヘッダーをチェック
            required_headers = {
                'X-Content-Type-Options': 'nosniff',
                'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
                'X-XSS-Protection': '1; mode=block',
                'Referrer-Policy': 'strict-origin-when-cross-origin'
            }
            
            missing_headers = []
            weak_headers = []
            
            for header, expected_values in required_headers.items():
                if header not in headers:
                    missing_headers.append(header)
                else:
                    header_value = headers[header]
                    if isinstance(expected_values, list):
                        if header_value not in expected_values:
                            weak_headers.append(f"{header}: {header_value}")
                    elif header_value != expected_values:
                        weak_headers.append(f"{header}: {header_value}")
            
            # Content-Security-Policy の存在チェック
            if 'Content-Security-Policy' not in headers:
                missing_headers.append('Content-Security-Policy')
            
            # Strict-Transport-Security の存在チェック（HTTPS の場合）
            if self.base_url.startswith('https://') and 'Strict-Transport-Security' not in headers:
                missing_headers.append('Strict-Transport-Security')
            
            # 結果を評価
            if missing_headers or weak_headers:
                severity = "HIGH" if missing_headers else "MEDIUM"
                status = "FAIL"
                description = "セキュリティヘッダーが不足または不適切です"
                details = {
                    "missing_headers": missing_headers,
                    "weak_headers": weak_headers,
                    "present_headers": list(headers.keys())
                }
                recommendation = "不足しているセキュリティヘッダーを追加し、弱い設定を強化してください"
            else:
                severity = "LOW"
                status = "PASS"
                description = "セキュリティヘッダーが適切に設定されています"
                details = {"headers": dict(headers)}
                recommendation = "現在の設定を維持してください"
            
            self.results.append(VulnerabilityResult(
                test_name="セキュリティヘッダー",
                severity=severity,
                status=status,
                description=description,
                details=details,
                recommendation=recommendation
            ))
            
        except Exception as e:
            self.results.append(VulnerabilityResult(
                test_name="セキュリティヘッダー",
                severity="MEDIUM",
                status="WARNING",
                description=f"テスト実行中にエラーが発生: {str(e)}",
                details={"error": str(e)},
                recommendation="ネットワーク接続とエンドポイントの可用性を確認してください"
            ))
    
    def test_ssl_configuration(self):
        """SSL/TLS 設定のテスト"""
        
        if not self.base_url.startswith('https://'):
            self.results.append(VulnerabilityResult(
                test_name="SSL/TLS設定",
                severity="HIGH",
                status="FAIL",
                description="HTTPS が使用されていません",
                details={"protocol": "HTTP"},
                recommendation="HTTPS を有効にしてください"
            ))
            return
        
        try:
            response = self.session.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
            
            # SSL 証明書の基本チェック
            ssl_info = {
                "status_code": response.status_code,
                "ssl_enabled": True
            }
            
            self.results.append(VulnerabilityResult(
                test_name="SSL/TLS設定",
                severity="LOW",
                status="PASS",
                description="HTTPS が有効になっています",
                details=ssl_info,
                recommendation="SSL/TLS 設定を定期的に見直してください"
            ))
            
        except requests.exceptions.SSLError as e:
            self.results.append(VulnerabilityResult(
                test_name="SSL/TLS設定",
                severity="HIGH",
                status="FAIL",
                description=f"SSL/TLS エラー: {str(e)}",
                details={"ssl_error": str(e)},
                recommendation="SSL/TLS 証明書と設定を確認してください"
            ))
        except Exception as e:
            self.results.append(VulnerabilityResult(
                test_name="SSL/TLS設定",
                severity="MEDIUM",
                status="WARNING",
                description=f"SSL/TLS テスト中にエラーが発生: {str(e)}",
                details={"error": str(e)},
                recommendation="ネットワーク接続を確認してください"
            ))
    
    def test_information_disclosure(self):
        """情報漏洩のテスト"""
        
        sensitive_endpoints = [
            "/api/v1/docs",
            "/api/v1/redoc", 
            "/docs",
            "/redoc",
            "/swagger",
            "/api/swagger",
            "/.env",
            "/config",
            "/admin",
            "/debug"
        ]
        
        disclosed_endpoints = []
        
        for endpoint in sensitive_endpoints:
            try:
                response = self.session.get(f"{self.base_url}{endpoint}", timeout=self.timeout)
                if response.status_code == 200:
                    disclosed_endpoints.append({
                        "endpoint": endpoint,
                        "status_code": response.status_code,
                        "content_length": len(response.content)
                    })
            except Exception:
                # エンドポイントが存在しない場合は正常
                pass
        
        if disclosed_endpoints:
            severity = "MEDIUM"
            status = "FAIL"
            description = "機密情報が公開されている可能性があります"
            recommendation = "本番環境では API ドキュメントや管理画面を無効にしてください"
        else:
            severity = "LOW"
            status = "PASS"
            description = "機密情報の漏洩は検出されませんでした"
            recommendation = "現在の設定を維持してください"
        
        self.results.append(VulnerabilityResult(
            test_name="情報漏洩",
            severity=severity,
            status=status,
            description=description,
            details={"disclosed_endpoints": disclosed_endpoints},
            recommendation=recommendation
        ))
    
    def test_authentication_bypass(self):
        """認証バイパスのテスト"""
        
        protected_endpoints = [
            "/api/v1/users",
            "/api/v1/users/me",
            "/api/v1/admin"
        ]
        
        bypass_attempts = []
        
        for endpoint in protected_endpoints:
            try:
                # 認証なしでアクセス
                response = self.session.get(f"{self.base_url}{endpoint}", timeout=self.timeout)
                
                if response.status_code == 200:
                    bypass_attempts.append({
                        "endpoint": endpoint,
                        "status_code": response.status_code,
                        "method": "無認証アクセス"
                    })
                
                # 無効なトークンでアクセス
                headers = {"Authorization": "Bearer invalid_token"}
                response = self.session.get(
                    f"{self.base_url}{endpoint}", 
                    headers=headers, 
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    bypass_attempts.append({
                        "endpoint": endpoint,
                        "status_code": response.status_code,
                        "method": "無効なトークン"
                    })
                    
            except Exception:
                # エラーは正常（認証が機能している）
                pass
        
        if bypass_attempts:
            severity = "CRITICAL"
            status = "FAIL"
            description = "認証バイパスが可能です"
            recommendation = "認証機能を強化し、すべての保護されたエンドポイントで認証を必須にしてください"
        else:
            severity = "LOW"
            status = "PASS"
            description = "認証バイパスは検出されませんでした"
            recommendation = "現在の認証設定を維持してください"
        
        self.results.append(VulnerabilityResult(
            test_name="認証バイパス",
            severity=severity,
            status=status,
            description=description,
            details={"bypass_attempts": bypass_attempts},
            recommendation=recommendation
        ))
    
    def test_sql_injection(self):
        """SQL インジェクションのテスト"""
        
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "1' AND 1=1 --",
            "admin'--"
        ]
        
        vulnerable_endpoints = []
        
        for payload in sql_payloads:
            try:
                # GET パラメータでテスト
                response = self.session.get(
                    f"{self.base_url}/api/v1/users",
                    params={"search": payload},
                    timeout=self.timeout
                )
                
                # エラーメッセージで SQL エラーを検出
                if any(keyword in response.text.lower() for keyword in 
                       ["sql", "mysql", "postgresql", "sqlite", "syntax error"]):
                    vulnerable_endpoints.append({
                        "endpoint": "/api/v1/users",
                        "method": "GET",
                        "payload": payload,
                        "response_snippet": response.text[:200]
                    })
                
                # POST データでテスト
                response = self.session.post(
                    f"{self.base_url}/api/v1/auth/login",
                    json={"email": payload, "password": "test"},
                    timeout=self.timeout
                )
                
                if any(keyword in response.text.lower() for keyword in 
                       ["sql", "mysql", "postgresql", "sqlite", "syntax error"]):
                    vulnerable_endpoints.append({
                        "endpoint": "/api/v1/auth/login",
                        "method": "POST",
                        "payload": payload,
                        "response_snippet": response.text[:200]
                    })
                    
            except Exception:
                # エラーは正常（適切にハンドリングされている）
                pass
        
        if vulnerable_endpoints:
            severity = "CRITICAL"
            status = "FAIL"
            description = "SQL インジェクション脆弱性が検出されました"
            recommendation = "パラメータ化クエリを使用し、入力値の検証を強化してください"
        else:
            severity = "LOW"
            status = "PASS"
            description = "SQL インジェクション脆弱性は検出されませんでした"
            recommendation = "現在のセキュリティ対策を維持してください"
        
        self.results.append(VulnerabilityResult(
            test_name="SQL インジェクション",
            severity=severity,
            status=status,
            description=description,
            details={"vulnerable_endpoints": vulnerable_endpoints},
            recommendation=recommendation
        ))
    
    def test_xss_protection(self):
        """XSS 保護のテスト"""
        
        xss_payloads = [
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "javascript:alert('xss')",
            "<svg onload=alert('xss')>",
            "';alert('xss');//"
        ]
        
        vulnerable_endpoints = []
        
        for payload in xss_payloads:
            try:
                response = self.session.get(
                    f"{self.base_url}/api/v1/users",
                    params={"search": payload},
                    timeout=self.timeout
                )
                
                # レスポンスにペイロードがそのまま含まれているかチェック
                if payload in response.text:
                    vulnerable_endpoints.append({
                        "endpoint": "/api/v1/users",
                        "method": "GET",
                        "payload": payload,
                        "reflected": True
                    })
                    
            except Exception:
                pass
        
        if vulnerable_endpoints:
            severity = "HIGH"
            status = "FAIL"
            description = "XSS 脆弱性が検出されました"
            recommendation = "出力エスケープを実装し、CSP ヘッダーを強化してください"
        else:
            severity = "LOW"
            status = "PASS"
            description = "XSS 脆弱性は検出されませんでした"
            recommendation = "現在のセキュリティ対策を維持してください"
        
        self.results.append(VulnerabilityResult(
            test_name="XSS 保護",
            severity=severity,
            status=status,
            description=description,
            details={"vulnerable_endpoints": vulnerable_endpoints},
            recommendation=recommendation
        ))
    
    def test_csrf_protection(self):
        """CSRF 保護のテスト"""
        
        try:
            # CSRF トークンなしで状態変更操作を試行
            response = self.session.post(
                f"{self.base_url}/api/v1/users",
                json={"username": "testuser", "email": "test@example.com"},
                timeout=self.timeout
            )
            
            # 認証が必要なエンドポイントで 401/403 が返されることを確認
            if response.status_code in [401, 403]:
                severity = "LOW"
                status = "PASS"
                description = "CSRF 保護が適切に機能しています"
                recommendation = "現在の設定を維持してください"
            else:
                severity = "MEDIUM"
                status = "WARNING"
                description = "CSRF 保護の確認が必要です"
                recommendation = "CSRF トークンの実装を検討してください"
            
            self.results.append(VulnerabilityResult(
                test_name="CSRF 保護",
                severity=severity,
                status=status,
                description=description,
                details={"response_status": response.status_code},
                recommendation=recommendation
            ))
            
        except Exception as e:
            self.results.append(VulnerabilityResult(
                test_name="CSRF 保護",
                severity="MEDIUM",
                status="WARNING",
                description=f"CSRF テスト中にエラーが発生: {str(e)}",
                details={"error": str(e)},
                recommendation="エンドポイントの可用性を確認してください"
            ))
    
    def test_rate_limiting(self):
        """レート制限のテスト"""
        
        try:
            # 短時間で大量のリクエストを送信
            responses = []
            start_time = time.time()
            
            for i in range(20):
                response = self.session.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
                responses.append(response.status_code)
                
                # 429 (Too Many Requests) が返された場合は制限が機能している
                if response.status_code == 429:
                    break
            
            end_time = time.time()
            duration = end_time - start_time
            
            # レート制限の評価
            if 429 in responses:
                severity = "LOW"
                status = "PASS"
                description = "レート制限が適切に機能しています"
                recommendation = "現在の設定を維持してください"
            else:
                severity = "MEDIUM"
                status = "WARNING"
                description = "レート制限が検出されませんでした"
                recommendation = "レート制限の実装を検討してください"
            
            self.results.append(VulnerabilityResult(
                test_name="レート制限",
                severity=severity,
                status=status,
                description=description,
                details={
                    "responses": responses,
                    "duration": duration,
                    "requests_per_second": len(responses) / duration
                },
                recommendation=recommendation
            ))
            
        except Exception as e:
            self.results.append(VulnerabilityResult(
                test_name="レート制限",
                severity="MEDIUM",
                status="WARNING",
                description=f"レート制限テスト中にエラーが発生: {str(e)}",
                details={"error": str(e)},
                recommendation="ネットワーク接続を確認してください"
            ))
    
    def test_directory_traversal(self):
        """ディレクトリトラバーサルのテスト"""
        
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "....//....//....//etc/passwd"
        ]
        
        vulnerable_endpoints = []
        
        for payload in traversal_payloads:
            try:
                response = self.session.get(
                    f"{self.base_url}/api/v1/users/{payload}",
                    timeout=self.timeout
                )
                
                # システムファイルの内容が返されているかチェック
                if any(keyword in response.text.lower() for keyword in 
                       ["root:", "administrator", "system32", "/bin/bash"]):
                    vulnerable_endpoints.append({
                        "endpoint": f"/api/v1/users/{payload}",
                        "payload": payload,
                        "response_snippet": response.text[:200]
                    })
                    
            except Exception:
                pass
        
        if vulnerable_endpoints:
            severity = "HIGH"
            status = "FAIL"
            description = "ディレクトリトラバーサル脆弱性が検出されました"
            recommendation = "ファイルパスの検証を強化し、アクセス制御を実装してください"
        else:
            severity = "LOW"
            status = "PASS"
            description = "ディレクトリトラバーサル脆弱性は検出されませんでした"
            recommendation = "現在のセキュリティ対策を維持してください"
        
        self.results.append(VulnerabilityResult(
            test_name="ディレクトリトラバーサル",
            severity=severity,
            status=status,
            description=description,
            details={"vulnerable_endpoints": vulnerable_endpoints},
            recommendation=recommendation
        ))
    
    def test_http_methods(self):
        """HTTP メソッドのテスト"""
        
        dangerous_methods = ["TRACE", "TRACK", "DEBUG", "CONNECT"]
        allowed_methods = []
        
        for method in dangerous_methods:
            try:
                response = self.session.request(
                    method, 
                    f"{self.base_url}/api/v1/health", 
                    timeout=self.timeout
                )
                
                if response.status_code != 405:  # Method Not Allowed
                    allowed_methods.append({
                        "method": method,
                        "status_code": response.status_code
                    })
                    
            except Exception:
                pass
        
        if allowed_methods:
            severity = "MEDIUM"
            status = "FAIL"
            description = "危険な HTTP メソッドが許可されています"
            recommendation = "不要な HTTP メソッドを無効にしてください"
        else:
            severity = "LOW"
            status = "PASS"
            description = "HTTP メソッドが適切に制限されています"
            recommendation = "現在の設定を維持してください"
        
        self.results.append(VulnerabilityResult(
            test_name="HTTP メソッド",
            severity=severity,
            status=status,
            description=description,
            details={"allowed_dangerous_methods": allowed_methods},
            recommendation=recommendation
        ))
    
    def test_cors_configuration(self):
        """CORS 設定のテスト"""
        
        try:
            # CORS プリフライトリクエスト
            response = self.session.options(
                f"{self.base_url}/api/v1/users",
                headers={
                    "Origin": "https://malicious-site.com",
                    "Access-Control-Request-Method": "GET",
                    "Access-Control-Request-Headers": "Authorization"
                },
                timeout=self.timeout
            )
            
            cors_headers = {
                "Access-Control-Allow-Origin": response.headers.get("Access-Control-Allow-Origin"),
                "Access-Control-Allow-Methods": response.headers.get("Access-Control-Allow-Methods"),
                "Access-Control-Allow-Headers": response.headers.get("Access-Control-Allow-Headers"),
                "Access-Control-Allow-Credentials": response.headers.get("Access-Control-Allow-Credentials")
            }
            
            # 危険な CORS 設定をチェック
            issues = []
            
            if cors_headers["Access-Control-Allow-Origin"] == "*":
                if cors_headers["Access-Control-Allow-Credentials"] == "true":
                    issues.append("ワイルドカード Origin と Credentials の組み合わせは危険です")
            
            if cors_headers["Access-Control-Allow-Methods"]:
                dangerous_methods = ["DELETE", "PUT", "PATCH"]
                allowed_methods = cors_headers["Access-Control-Allow-Methods"].split(", ")
                for method in dangerous_methods:
                    if method in allowed_methods:
                        issues.append(f"危険な HTTP メソッド {method} が CORS で許可されています")
            
            if issues:
                severity = "MEDIUM"
                status = "WARNING"
                description = "CORS 設定に問題があります"
                recommendation = "CORS 設定を見直し、必要最小限の権限に制限してください"
            else:
                severity = "LOW"
                status = "PASS"
                description = "CORS 設定は適切です"
                recommendation = "現在の設定を維持してください"
            
            self.results.append(VulnerabilityResult(
                test_name="CORS 設定",
                severity=severity,
                status=status,
                description=description,
                details={"cors_headers": cors_headers, "issues": issues},
                recommendation=recommendation
            ))
            
        except Exception as e:
            self.results.append(VulnerabilityResult(
                test_name="CORS 設定",
                severity="MEDIUM",
                status="WARNING",
                description=f"CORS テスト中にエラーが発生: {str(e)}",
                details={"error": str(e)},
                recommendation="エンドポイントの可用性を確認してください"
            ))
    
    def test_error_handling(self):
        """エラーハンドリングのテスト"""
        
        try:
            # 存在しないエンドポイント
            response = self.session.get(f"{self.base_url}/api/v1/nonexistent", timeout=self.timeout)
            
            # エラーレスポンスで機密情報が漏洩していないかチェック
            sensitive_info = [
                "traceback", "stack trace", "debug", "exception",
                "database", "sql", "password", "secret", "key",
                "internal server error", "500 internal server error"
            ]
            
            leaked_info = []
            response_text = response.text.lower()
            
            for info in sensitive_info:
                if info in response_text:
                    leaked_info.append(info)
            
            if leaked_info:
                severity = "MEDIUM"
                status = "FAIL"
                description = "エラーレスポンスで機密情報が漏洩しています"
                recommendation = "エラーハンドリングを改善し、機密情報を隠してください"
            else:
                severity = "LOW"
                status = "PASS"
                description = "エラーハンドリングは適切です"
                recommendation = "現在の設定を維持してください"
            
            self.results.append(VulnerabilityResult(
                test_name="エラーハンドリング",
                severity=severity,
                status=status,
                description=description,
                details={
                    "status_code": response.status_code,
                    "leaked_info": leaked_info,
                    "response_snippet": response.text[:200]
                },
                recommendation=recommendation
            ))
            
        except Exception as e:
            self.results.append(VulnerabilityResult(
                test_name="エラーハンドリング",
                severity="MEDIUM",
                status="WARNING",
                description=f"エラーハンドリングテスト中にエラーが発生: {str(e)}",
                details={"error": str(e)},
                recommendation="ネットワーク接続を確認してください"
            ))
    
    def generate_report(self, output_file: str = None) -> str:
        """スキャン結果のレポートを生成"""
        
        # 結果を重要度別に分類
        critical = [r for r in self.results if r.severity == "CRITICAL"]
        high = [r for r in self.results if r.severity == "HIGH"]
        medium = [r for r in self.results if r.severity == "MEDIUM"]
        low = [r for r in self.results if r.severity == "LOW"]
        
        # レポート生成
        report = f"""
# セキュリティスキャンレポート

## 概要
- スキャン対象: {self.base_url}
- スキャン日時: {time.strftime('%Y-%m-%d %H:%M:%S')}
- 総テスト数: {len(self.results)}

## 結果サマリー
- CRITICAL: {len(critical)} 件
- HIGH: {len(high)} 件
- MEDIUM: {len(medium)} 件
- LOW: {len(low)} 件

## 詳細結果

"""
        
        for severity_name, results in [
            ("CRITICAL", critical),
            ("HIGH", high), 
            ("MEDIUM", medium),
            ("LOW", low)
        ]:
            if results:
                report += f"### {severity_name} 重要度の問題\n\n"
                for result in results:
                    report += f"**{result.test_name}** - {result.status}\n"
                    report += f"- 説明: {result.description}\n"
                    report += f"- 推奨事項: {result.recommendation}\n"
                    if result.details:
                        report += f"- 詳細: {json.dumps(result.details, ensure_ascii=False, indent=2)}\n"
                    report += "\n"
        
        # ファイルに出力
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(report)
            logger.info(f"レポートを出力しました: {output_file}")
        
        return report


def main():
    """メイン関数"""
    
    parser = argparse.ArgumentParser(description='セキュリティ脆弱性スキャナー')
    parser.add_argument('url', help='スキャン対象のベース URL')
    parser.add_argument('--output', '-o', help='レポート出力ファイル')
    parser.add_argument('--timeout', '-t', type=int, default=10, help='リクエストタイムアウト（秒）')
    
    args = parser.parse_args()
    
    # スキャン実行
    scanner = SecurityScanner(args.url, args.timeout)
    results = scanner.scan_all()
    
    # レポート生成
    report = scanner.generate_report(args.output)
    
    # コンソールに結果表示
    print(report)
    
    # 重要な脆弱性がある場合は終了コード 1
    critical_issues = [r for r in results if r.severity in ["CRITICAL", "HIGH"] and r.status == "FAIL"]
    if critical_issues:
        print(f"\n⚠️  {len(critical_issues)} 件の重要な脆弱性が検出されました")
        exit(1)
    else:
        print("\n✅ 重要な脆弱性は検出されませんでした")
        exit(0)


if __name__ == "__main__":
    main()